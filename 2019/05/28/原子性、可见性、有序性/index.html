<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="ALemon">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="ALemon">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>原子性、可见性、有序性 · ALemon Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin="">
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin="">
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">ALemon&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">原子性、可见性、有序性</a>
            </div>
    </div>
    
    <a class="home-link" href="/">ALemon's Blog</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(http://ww1.sinaimg.cn/large/006D41sGly1g3se9z8jj3j356o3gg7wm.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            原子性、可见性、有序性
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java内存模型">Java内存模型</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">5.6k</span>阅读时长: <span class="post-count reading-time">19 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/05/28</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>经常听到或者面试都有人会问道这三个东西，我们可能会一下子就知道这三个概念都是什么意思。我自己想了一下，貌似我仅仅对于这三个概念了解概念以及在 Java 上如何实现而已。所以在这里就整理一下资料，对这三个概念进行一些深入的学习。</p>
<p>至于为什么会有存在这三个概念，一直不得其解，就搜索一些资料，自己也整理一下，算是补全一下自己的知识体系吧。</p>
<p><strong>主要介绍：</strong></p>
<ul>
<li>这三个概念的由来</li>
<li>对于这三个概念，具体在 Java 上又是如何实现的</li>
</ul>
<h3 id="三个概念的由来"><a href="#三个概念的由来" class="headerlink" title="三个概念的由来"></a>三个概念的由来</h3><h4 id="从硬件上分析"><a href="#从硬件上分析" class="headerlink" title="从硬件上分析"></a>从硬件上分析</h4><p>之前旧时代计算机的芯片都是单核的，那个时候的计算如果想要读写数据，每次都得从主内存（物理内存）中读取，修改完后再存放回主内存中。</p>
<p><img src="http://ww1.sinaimg.cn/large/006D41sGly1g3jtlb7yi9j30gm03rmx5.jpg" alt=""></p>
<p>然而在 CPU 中操作或修改数据也就是一会儿的事情而已，大多数的时间其实都花费在了和物理内存建立联系的过程中。之后为了解决这种尴尬，之后的芯片就引入<code>CPU高速缓存</code>一个<strong>存储部件</strong>，来提高数据的读写速率。</p>
<blockquote>
<p>在金字塔式存储体系中它位于自顶向下的第二层，仅次于<a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">CPU寄存器</a>。其容量远小于<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" target="_blank" rel="noopener">内存</a>，但速度却可以接近处理器的频率。（维基百科）</p>
</blockquote>
<p>CPU 缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快得多，举个例子：</p>
<ul>
<li>一次主内存的访问通常在几十到几百个时钟周期</li>
<li>一次<code>L1</code>高速缓存的读写只需要1~2个时钟周期</li>
<li>一次<code>L2</code>高速缓存的读写也只需要数十个时钟周期</li>
</ul>
<p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存（物理内存）当中。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006D41sGly1g3jtt8vgchj30qg0aiwfe.jpg" alt=""></p>
<p>好了，对于简单的数据处理，加上这个高速的缓存已经满足了要求。但是随着技术的发展和需求的变化，对于数据的计算越来越大，也越来越复杂，难道一将所有用到的数据都放在一个盘子中吗？对于这种情况，计算机芯片的设计大佬们又针对一些优先级别的数据设置了不同的级别缓存。</p>
<blockquote>
<p>简单地说，二级缓存就是一级缓存的缓冲器：一级缓存制造成本很高因此它的容量有限，二级缓存的作用就是存储那些CPU处理时需要用到、一级缓存又无法存储的数据。同样道理，三级缓存和内存可以看作是二级缓存的缓冲器，它们的容量递增，但单位制造成本却递减。</p>
</blockquote>
<p>现在我们用的电脑很多都是多核心、多级缓存的CPU。<strong>现代计算机都有<code>L1</code>和<code>L2</code>缓存</strong>，许多计算机现在还有<code>L3</code>缓存。</p>
<p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p>
<p>单核和多核的架构图如下两幅图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/006D41sGly1g3jtu4jv69j30o60ao0tr.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006D41sGly1g3sekdjulqj30fd0eo0z1.jpg" alt=""></p>
<p>单核CPU只含有一套<code>L1</code>，<code>L2</code>，<code>L3</code>缓存；</p>
<p>如果CPU含有多个核心，即多核CPU，则每个核心都含有一套<code>L1</code>（甚至和<code>L2</code>）缓存，而共享<code>L3</code>（或者和<code>L2</code>）缓存。</p>
<p>按照读取顺序与CPU结合的紧密程度来分，缓存可以分为下面三层</p>
<ul>
<li>通常 <code>L1</code>离 CPU 核心最近，<code>L1</code>的容量通常比<code>L2</code>小，容量大的<code>SRAM</code>访问时间就越长</li>
<li><code>L2</code>则处于边缓位置，访问数据时，<code>L2 Cache</code>需要通过更远的铜线，甚至更多的电路，从而增加了延时。</li>
<li><code>L3</code>缓存多个核心共用一个，通常也不区分指令和数据。 </li>
</ul>
<p>每一级缓存中所存储的数据全部都是下一级缓存中的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也相对递增。</p>
<p>好了，随着技术的发展，在硬件上处理数据的速度和数量都大大的提升了，但是在对于硬件的系统越来越复杂，也导致了软件设计的难度提升，具体一些表现如下：</p>
<blockquote>
<p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题</strong>（下图不同核读取主存中的数据做不同的操作导致对应的数据缓存不一致问题）。例如下图所示，在多处理器系统中，每个处理器都有置机的高速缓存，core1 和 core2 在内存中读取到的变量都是一样，但是因为操作不同，而又是共用同一个主内存，所以导致最终输出到缓存的变量不同，这就是 <u>缓存不一致</u>。</p>
</blockquote>
<p>如果出现上面说的缓存不一致的问题，那么程序是以那个写入主内存的缓存为准呢？</p>
<p>为了解决缓存一致性的问题，就需要各个处理器访问缓存时都需要遵循一些协议，在读写要根据协议来进行操作，这些协议有 MSI、MESI、MOSI、Synapse、Firefly 及 Dragon Protocol 等。</p>
<blockquote>
<p>除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化</strong>。</p>
<p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong>。</p>
</blockquote>
<p><img src="https://www.hollischuang.com/wp-content/uploads/2018/07/%E4%B8%80%E8%87%B4.png" alt=""></p>
<p align="right">——From 图片贴的是参考资料2 文章的图片</p>



<h4 id="Java-内存模型引入与作用"><a href="#Java-内存模型引入与作用" class="headerlink" title="Java 内存模型引入与作用"></a>Java 内存模型引入与作用</h4><p>既然有分有钱人和穷人，那对应着买的电脑也就有了“高低贵贱“之分了，那有没有存在一种手段，让程序编写一次就可以在不同的环境运行（不管你有多少个核和多少个高速缓存）。</p>
<p>无疑问的，这也就是了 Java 的宗旨【一处编写，随处可行】。</p>
<p>那 Java 究竟做了些什么，得以实现个目标的？</p>
<ul>
<li>Java 针对了不同的系统，搭建了一个 JVM 的虚拟机环境，让 Java 程序在里面运行。</li>
</ul>
<p>那又有问题了，JVM 这个虚拟机是如何管理数据，避免掉上述硬件产生的的缓存一致性问题、处理器优化问题和指令重排问题等呢？</p>
<ul>
<li>JVM 中引入呢 Java 内存模型的概念，管理各个Java 对象，要求我们只需要遵循它指定的规则，即可避免掉这些问题。</li>
</ul>
<blockquote>
<p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p>
</blockquote>
<p>这就和 C 与 C++ 不同了，C 和 C++ 是直接使用物理硬件和操作系统的内存模型，也是因为这样，在不同的平台或者操作系统上，开发出来同样的程序可能会在一个平台上并发正常，在另一个平台上，并发异常的情况发生。</p>
<p>其实在了解CPU和高速缓存的机制之后，都不难发现Java 内存管理模型对于上面的本地内存（工作内存）其实也就是对 CPU寄存器和高速缓存的抽象。或者说每个线程的本地内存也可以简单理解为CPU寄存器和高速缓存。</p>
<p>对于 Java 内存模型，我们这里不进行深入的说明<code>JMM</code>的数据访问规则，我们需要了解以下的内容即可理解本篇文章</p>
<ul>
<li><code>JMM</code>就作用于工作内存和主存之间数据同步过程（作用地点）。定了如何做数据同步以及什么时候做数据同步。</li>
<li><code>JMM</code>是一种符合内存模型规范，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的<strong>机制及规范</strong>。</li>
</ul>
<p>对于第二点，上面也已经解析的很清楚了，那再说一下第一点吧！</p>
<p>通俗一点说明就是 JMM 的目标是通过虚拟机帮我们处理 <strong>将变量存储到内存和从内存中取出变量</strong> 这样的底层细节。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存（本地内存），线程的工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间无法直接访问对方线程中工作内存中的变量，线程之间的变量值的传递需要通过主内存来完成，主内存、内存模型、工作内存、线程的关系如下图所示。</p>
<p><img src="https://www.hollischuang.com/wp-content/uploads/2018/07/JAVA.png" alt=""></p>
<p align="right">——From 图片贴的是参考资料2 文章的图片</p>



<p>好了，终于介绍完技术的缘由了。</p>
<p>其实，原子性问题，可见性问题和有序性问题，是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote>
<p> 即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</p>
</blockquote>
<p><strong>要想在多线程环境下保证原子性，Java 提供了Lock、synchronized、原子类来确保。volatile是无法保证复合操作的原子性。</strong></p>
<p>这里说明一下 volatile 为什么说它不具备原子性，对任意<code>单个</code>volatile变量的读/写具有原子性，但类似于 <code>i++</code> 这种<code>复合操作</code>不具有原子性。</p>
<p>（此处不对原子性做深入说明了，对于 <code>synchronized</code> 如何实现原子性有独立的文章另外说明。）</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><blockquote>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
</blockquote>
<p><strong>Java提供了volatile关键字来保证可见性</strong>。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p><img src="http://ww1.sinaimg.cn/large/006D41sGly1g3sejq80gkj30th0hytc6.jpg" alt="img"></p>
<p>图是引用 【石衫的架构笔记】的，对于介绍，它说得较为表面了，这里也用这个图示例子进行说明一下底层对于 volatile 关键字修饰的对象是如何保证可见性的。</p>
<ol>
<li>在执行 <code>data = 1</code> 之前，线程1 发出 LOCK# 指令，锁总线（或者缓存行），同时让 线程2 中 data 对象对应的缓存行失效</li>
<li>执行 <code>data = 1</code>时候，线程1 向主内存回写最新的修改 data 对象</li>
<li>线程2 读取/执行 data 对象的时候，会发现之前读取进入工作内存的 data 对象的缓存行给锁住了，等待锁的释放，<strong>缓存一致性协议</strong>会保证它读取到最新的值。</li>
</ol>
<p>此时，他就必须重新从主内存中加载data变量最新的值！那么不就可以读取到data = 1这个最新的值了</p>
<blockquote>
<p><strong>volatile 关键字底层是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值。</strong>这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是 <code>volatile</code> 变量都是如此，普通变量与 <code>volatile</code> 变量的区别是， <code>volatile</code> 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新（底层由缓存一致性协议来保证）。</p>
</blockquote>
<blockquote>
<p><strong>由此可以看出，volatile关键字的读和普通变量的读取相比基本没差别，差别主要还是在变量的写操作上。</strong></p>
</blockquote>
<p>因此，可以说 <code>volatile</code> 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<blockquote>
<p>除了 <code>volatile</code> 关键字可以实现可见性，还有两个关键字可以实现可见性，即 <code>synchronized</code> 和<br><code>final</code> 。</p>
</blockquote>
<p><code>synchronized</code>通过锁保证每次的修改变量的只有一个线程，然后数据也会回刷到主内存当中，保证了数据的可见性。</p>
<p>在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个<code>StoreStore</code>屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>上面已经说明过，程序的有序性问题根本原因是由于计算机的指令重排序造成的，所以说明有序性之前，首先得重排序的概念</p>
<h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a><strong>重排序</strong></h4><p><strong>编译器和处理器为了提高并行度，会对程序进行重排序</strong>，不能保证变量赋值的操作顺序与程序代码中的执行顺序一致。</p>
<blockquote>
<p>指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p>
</blockquote>
<p>然而，指令重排是一把双刃剑，虽然优化了程序的执行效率，但是在某些情况下，会影响到多线程的执行结果。我们来看看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> contextReady = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线程A中执行:</span></span><br><span class="line">context = loadContext();</span><br><span class="line">contextReady = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线程B中执行:</span></span><br><span class="line"><span class="keyword">while</span>( ! contextReady )&#123; </span><br><span class="line">   sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">doAfterContextReady (context);</span><br></pre></td></tr></table></figure>
<p>以上程序看似没有问题。线程B循环等待上下文context的加载，一旦context加载完成，contextReady == true的时候，才执行doAfterContextReady 方法。</p>
<p>但是，如果线程A执行的代码发生了指令重排，初始化和<code>contextReady</code>的赋值交换了顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> contextReady = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线程A中执行:</span></span><br><span class="line">contextReady = <span class="keyword">true</span>;</span><br><span class="line">context = loadContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线程B中执行:</span></span><br><span class="line"><span class="keyword">while</span>( ! contextReady )&#123; </span><br><span class="line">   sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">doAfterContextReady (context);</span><br></pre></td></tr></table></figure>
<p>这个时候，很可能context对象还没有加载完成，变量<code>contextReady</code> 已经为true，线程B直接跳出了循环等待，开始执行<code>doAfterContextRead</code>y 方法，结果自然会出现错误。</p>
<p>==<strong>需要注意的是，这里Java代码的重排只是为了简单示意，真正的指令重排是在字节码指令的层面。</strong>==</p>
<p>那，需要保证我们的程序在多线程的时候，能够按照指定的顺序执行，那就是有序性了。</p>
<p>Java语言提供了 <code>volatile</code> 和 <code>synchronized</code> 两个关键字来保证线程之间操作的有序性。</p>
<h4 id="volatile-如何保证有序性？"><a href="#volatile-如何保证有序性？" class="headerlink" title="volatile 如何保证有序性？"></a><code>volatile</code> 如何保证有序性？</h4><p>这里就进行说明</p>
<ul>
<li>volatile 究竟做了什么操作，在指令重排的时候，保证了 volatile 修饰的对象的有序性</li>
</ul>
<p>为了说明 volatile 具体做了什么，我们需要先了解一波 “内存屏障” 的定义：</p>
<blockquote>
<p>A memory barrier, also known as a membar, memory fence or fence instruction, is a type of barrier instruction that causes a CPU or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.</p>
<p><strong>内存屏障</strong>（英语：Memory barrier），也称<strong>内存栅栏</strong>，<strong>内存栅障</strong>，<strong>屏障指令</strong>等，是一类<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C" target="_blank" rel="noopener">同步屏障</a>指令，它使得 CPU 或编译器在对内存进行操作的时候，严格按照一定的顺序来执行, 也就是说在<u>memory barrier 之前的指令和memory barrier之后的指令不会由于系统优化等原因而导致乱序</u>。</p>
<p>大多数现代计算机为了提高性能而采取<a href="https://zh.wikipedia.org/wiki/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">乱序执行</a>，这使得内存屏障成为必须。</p>
<p>语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。</p>
</blockquote>
<p align="right">——From Wiki</p>



<p>内存屏障共分为四种类型：</p>
<ul>
<li><p><strong>LoadLoad屏障</strong></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1; </span><br><span class="line">LoadLoad; </span><br><span class="line">Load2</span><br></pre></td></tr></table></figure>
<p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
</li>
</ul>
</li>
<li><p><strong>StoreStore屏障</strong></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1; </span><br><span class="line">StoreStore; </span><br><span class="line">Store2</span><br></pre></td></tr></table></figure>
<p>Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见（也就是在执行 Store2 之前的写操作，必须完成，且回刷到主存中，保证了之前的操作已经完成实现有序性）</p>
</li>
</ul>
</li>
<li><p><strong>LoadStore屏障</strong></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1; </span><br><span class="line">LoadStore; </span><br><span class="line">Store2</span><br></pre></td></tr></table></figure>
<p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p>
</li>
</ul>
</li>
<li><p><strong>StoreLoad屏障</strong></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1; </span><br><span class="line">StoreLoad; </span><br><span class="line">Load2</span><br></pre></td></tr></table></figure>
<p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。</p>
<p><code>StoreLoad</code>屏障的开销是四种屏障中最大的。也正是这个屏障指令，也就实现了上面所说的可见性，让写的变量回刷（保存、更新）到主内存当中。</p>
</li>
</ul>
</li>
</ul>
<p>介绍完内存屏障指令后，那我们就说明一下，我们在对 <code>volatile</code> 关键字修饰的对象做读写操作时候，<code>JMM</code>会帮我们做些什么，保证该对象的有序性与可见性呢？</p>
<p><code>JMM</code>会为我们做两件事：</p>
<blockquote>
<ul>
<li>在每个volatile写操作前插入<strong><code>StoreStore</code></strong>屏障，在写操作后插入<strong><code>StoreLoad</code></strong>屏障。</li>
<li>在每个volatile读操作前插入<strong><code>LoadLoad</code></strong>屏障，在读操作后插入<strong><code>LoadStore</code></strong>屏障。</li>
</ul>
</blockquote>
<p>其实从指令层面上面看呢，我们拿到编译后的指令看，会发现在修改 <code>volatile</code> 关键字修饰的变量的值的时候，会有一个指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock addl $<span class="number">0x0</span>,(%esp)</span><br></pre></td></tr></table></figure>
<p>意思是把修改同步到内存当中，也意味着之前所有的操作已经执行完成，这样便形成了 “指令重排序无法越过内存屏障” 的效果。</p>
<p><strong>另外说明</strong>：只有一个CPU访问是不需要这个内存屏障的，但是多个CPU 访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性了。</p>
<p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。</p>
<h4 id="synchronized-如何保证有序性"><a href="#synchronized-如何保证有序性" class="headerlink" title="synchronized 如何保证有序性"></a><code>synchronized</code> 如何保证有序性</h4><p>而 <code>synchronized</code> 则是由“一个变量在同个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了锁定的代码块结果就和单线程的结果一样，对于单线程，不存在重排序导致结果冲突的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>硬件的升级导致了缓存一致性问题</li>
<li>Java 内存模型功能，对应线程工作内存问题可类比到硬件上的缓存一致性问题</li>
<li>原子性、可见性、有序性究竟是什么，Java 对于这些问题有什么的解决办法</li>
<li>volatile 关键字保证了变量的新值能立即同步到内存中，以及每次使用前都立即从内存刷新</li>
<li><code>synchronized</code> 关键字都可以实现上面说的三个问题，但是越通用的东西，自然也伴随着越大的性能影响（具体之后在锁、synchronized 底层实现的时候再说）</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.itcodemonkey.com/article/1725.html" target="_blank" rel="noopener">漫画：volatile对指令重排的影响</a></p>
<p><a href="https://www.hollischuang.com/archives/2550" target="_blank" rel="noopener">再有人问你Java内存模型是什么，就把这篇文章发给他。</a></p>
<p><a href="https://www.cnblogs.com/xrq730/p/7048693.html" target="_blank" rel="noopener">就是要你懂Java中volatile关键字实现原理</a></p>
<p><a href="http://ifeve.com/java-memory-model/" target="_blank" rel="noopener">深入理解Java内存模型（六）——final</a></p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://a998151.github.io">ALemon</a>
            </p><p>原文链接：<a href="https://a998151.github.io/2019/05/28/原子性、可见性、有序性/">https://a998151.github.io/2019/05/28/原子性、可见性、有序性/</a>
            </p><p>发表日期：<a href="https://a998151.github.io/2019/05/28/原子性、可见性、有序性/">May 28th 2019, 8:20:05 pm</a>
            </p><p>更新日期：<a href="https://a998151.github.io/2019/05/28/原子性、可见性、有序性/">July 23rd 2019, 11:21:11 pm</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2019/05/31/一点想法/" title="一点想法或反思">
                    <div class="nextTitle">一点想法或反思</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2019/05/17/Java集合——Map/" title="Java集合——Map">
                    <div class="prevTitle">Java集合——Map</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:756775896@qq.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="https://github.com/a998151" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#三个概念的由来"><span class="toc-number">1.</span> <span class="toc-text">三个概念的由来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从硬件上分析"><span class="toc-number">1.1.</span> <span class="toc-text">从硬件上分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-内存模型引入与作用"><span class="toc-number">1.2.</span> <span class="toc-text">Java 内存模型引入与作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性"><span class="toc-number">2.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性"><span class="toc-number">3.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序性"><span class="toc-number">4.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重排序"><span class="toc-number">4.1.</span> <span class="toc-text">重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-如何保证有序性？"><span class="toc-number">4.2.</span> <span class="toc-text">volatile 如何保证有序性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-如何保证有序性"><span class="toc-number">4.3.</span> <span class="toc-text">synchronized 如何保证有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number"></span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">1.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 30
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/18</span><a class="archive-post-title" href="/2019/12/18/多路复用/">I/O多路复用原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/02</span><a class="archive-post-title" href="/2019/10/02/布隆个过滤器与Hash函数的学习/">布隆个过滤器与Hash函数的学习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span><a class="archive-post-title" href="/2019/09/26/ClassLoader/">类加载器ClassLoader</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/28</span><a class="archive-post-title" href="/2019/08/28/雪花算法（SnowFlake）/">雪花算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span><a class="archive-post-title" href="/2019/08/13/线程池工作原理/">线程池工作原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/27</span><a class="archive-post-title" href="/2019/07/27/内存间的交互操作（深入理解Java虚拟机II笔记）/">JVM内存间交互（深入理解Java虚拟机II笔记）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span><a class="archive-post-title" href="/2019/07/05/垃圾收集器——哪些对象可以回收？（深入理解Java虚拟机II笔记）/">GC——哪些对象可以回收？（深入理解Java虚拟机II笔记）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href="/2019/07/04/介绍垃圾收集器背景（深入理解Java虚拟机II笔记）/">介绍垃圾收集器背景（深入理解Java虚拟机II笔记）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/03</span><a class="archive-post-title" href="/2019/07/03/JVM内存溢出异常探究/">JVM内存溢出异常探究（深入理解Java虚拟机II笔记）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href="/2019/06/20/Java对象探究（深入理解Java虚拟机II笔记）/">Java对象探究（深入理解Java虚拟机II笔记）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/16</span><a class="archive-post-title" href="/2019/06/16/Java 内存区域/">Java内存区域（深入理解Java虚拟机II笔记）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span><a class="archive-post-title" href="/2019/05/31/一点想法/">一点想法或反思</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span><a class="archive-post-title" href="/2019/05/28/原子性、可见性、有序性/">原子性、可见性、有序性</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/17</span><a class="archive-post-title" href="/2019/05/17/Java集合——Map/">Java集合——Map</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span><a class="archive-post-title" href="/2019/05/09/单点登陆/">单点登陆</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href="/2019/05/03/Java集合——Set/">Java集合——Set</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/02</span><a class="archive-post-title" href="/2019/05/02/Java集合——List/">Java集合——List</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span><a class="archive-post-title" href="/2019/05/01/数据库管理系统（DBMS）——事务隔离级别/">数据库管理系统（DBMS）——事务与隔离级别</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href="/2019/04/13/数据库管理系统（DBMS）——读现象/">数据库管理系统（DBMS）——读现象</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span><a class="archive-post-title" href="/2019/04/11/数据库管理系统（DBMS）——共享锁与排他锁/">数据库管理系统（DBMS）——共享锁与排他锁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href="/2019/04/10/数据库管理系统（DBMS）——行锁、表锁、页锁/">数据库管理系统（DBMS）中的锁——行锁、表锁、页锁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href="/2019/04/10/数据库管理系统（DBMS）——死锁/">数据库管理系统（DBMS）——死锁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/30</span><a class="archive-post-title" href="/2019/03/30/Java中的锁/">Java 锁（updating）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/20</span><a class="archive-post-title" href="/2019/03/20/Java 多线程（并发）/">Java 多线程（并发）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span><a class="archive-post-title" href="/2019/03/01/static 多线程/">Java中多线程的static</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span><a class="archive-post-title" href="/2019/02/04/final 关键字深入理解/">final 关键字的理解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href="/2019/01/04/类型信息/">Java——Class</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href="/2018/12/21/泛型/">泛型使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href="/2018/10/24/Java初认识锁机制/">Java初认识锁机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span><a class="archive-post-title" href="/2018/10/04/Java 中的 ==, equals 与 hashCode 的区别与联系/">Java 中的 ==、equals 与 hashCode</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="JVM"><span class="iconfont-archer">&#xe606;</span>JVM</span>
    
        <span class="sidebar-tag-name" data-tags="内存溢出"><span class="iconfont-archer">&#xe606;</span>内存溢出</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="锁"><span class="iconfont-archer">&#xe606;</span>锁</span>
    
        <span class="sidebar-tag-name" data-tags="反思"><span class="iconfont-archer">&#xe606;</span>反思</span>
    
        <span class="sidebar-tag-name" data-tags="单点登陆"><span class="iconfont-archer">&#xe606;</span>单点登陆</span>
    
        <span class="sidebar-tag-name" data-tags="SSO"><span class="iconfont-archer">&#xe606;</span>SSO</span>
    
        <span class="sidebar-tag-name" data-tags="OAuth2.0"><span class="iconfont-archer">&#xe606;</span>OAuth2.0</span>
    
        <span class="sidebar-tag-name" data-tags="内存区域"><span class="iconfont-archer">&#xe606;</span>内存区域</span>
    
        <span class="sidebar-tag-name" data-tags="Java对象"><span class="iconfont-archer">&#xe606;</span>Java对象</span>
    
        <span class="sidebar-tag-name" data-tags="Map"><span class="iconfont-archer">&#xe606;</span>Map</span>
    
        <span class="sidebar-tag-name" data-tags="总结"><span class="iconfont-archer">&#xe606;</span>总结</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="Java内存模型"><span class="iconfont-archer">&#xe606;</span>Java内存模型</span>
    
        <span class="sidebar-tag-name" data-tags="GC"><span class="iconfont-archer">&#xe606;</span>GC</span>
    
        <span class="sidebar-tag-name" data-tags="内存"><span class="iconfont-archer">&#xe606;</span>内存</span>
    
        <span class="sidebar-tag-name" data-tags="线程池"><span class="iconfont-archer">&#xe606;</span>线程池</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "ALemon"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


