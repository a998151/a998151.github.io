<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="ALemon">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="ALemon">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Java 多线程（并发） · ALemon Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin="">
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin="">
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">ALemon&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Java 多线程（并发）</a>
            </div>
    </div>
    
    <a class="home-link" href="/">ALemon's Blog</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(http://ww1.sinaimg.cn/large/006D41sGgy1g1lt8wyjxrj3334223aw0.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Java 多线程（并发）
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Java">Java</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="多线程">多线程</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">5.5k</span>阅读时长: <span class="post-count reading-time">21 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/03/20</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>有一个大水缸，要和尚去挑水，倒满这个水缸，如果需要挑20趟才能给这个水缸加满水。</p>
<p>让一个和尚来回跑20趟，挑20次水，就可以倒满。</p>
<p>另外我也可以让 10 个和尚跑两趟，就可以把水缸的水给倒满。</p>
<p>第二种场景就是<strong>并发</strong>。并发编程主要解决的问题为 “速度（效率）”。</p>
<p>但是一条路就这么宽，十个和尚跑在路上，如果碰倒了，导致水洒了，两趟下来，就保证不了水缸能够装满水。</p>
<p>所以在并发的情况下，我们需要考虑的在这条挑水的路上各个和尚正常挑水不发生意外，不像一个和尚挑水，在路上不用担心碰倒其它和尚。</p>
<p>上面提到的地方就是并发需要注意的：阻塞、共享资源。另外为了解决这些问题，而又有涉及到一些概念：原子性、有序性、可见性、多线程的重排序。</p>
<h4 id="1-1-进程与线程"><a href="#1-1-进程与线程" class="headerlink" title="1.1 进程与线程"></a>1.1 进程与线程</h4><p>这里定义和线程相关的另一个术语-<strong>进程</strong>：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。<strong>一个线程不能独立的存在，它必须是进程的一部分</strong>。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。</p>
<h4 id="1-2-并发的目的"><a href="#1-2-并发的目的" class="headerlink" title="1.2 并发的目的"></a>1.2 并发的目的</h4><p>并发目的就是让程序具有高效率。充分利用 CPU 的资源。</p>
<p><strong>一个<code>Java</code>程序运行至少是有两个线程的，一个是主线程main，另一个是垃圾回收线程。</strong></p>
<h3 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2.线程的生命周期"></a>2.线程的生命周期</h3><p><img src="http://ww1.sinaimg.cn/large/006D41sGgy1g1hfrwae6zj30nm07x75h.jpg" alt=""></p>
<p>当线程被创建并启动之后，它并不是一启动就进入了运行状态的，也不是一直处于执行状态的。在线程的生命周期中。它需要经过新建（new）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead） 5 种状态。</p>
<p>​    尤其是当耗时长线程启动之后，该线程不可能一直霸占着 CPU 独自运行，所以 CPU 也需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之前切换。</p>
<ul>
<li><strong>新建状态</strong>：创建线程对象，使用关键字 <code>new</code> 创建一个线程后，该线程就处于新建状态，此时仅由 <code>JVM</code>为这个线程分配了内存，并初始化其中成员变量的值而已。</li>
<li><strong>就绪状态</strong>：运行<code>start()</code>后，<code>Java</code>虚拟机为线程创建方法调用栈和程序计数器，等待调度执行。</li>
<li><strong>运行状态</strong>：有执行资格，有执行权（运行<code>run()</code>）</li>
<li><strong>阻塞状态</strong>：由于一些操作让线程放弃了 CPU 的使用权，处于该状态，没有执行资格，没有执行权。而需要另一些操作把他激活(<code>sleep()时间到，notify()</code>)，激活后处于就绪状态。阻塞情况分为三种：<ul>
<li>等待阻塞（<code>o.wait</code> -&gt; 等待队列）：运行的线程执行<code>o.wait()</code>方法，<code>JVM</code> 会把线程放入等待队列（<code>waitting queue</code>）中</li>
<li>同步阻塞（lock - &gt; 锁池）：运行的线程在获取对象同步锁的时候，发现这个锁给别的线程占用了，那 <code>JVM</code> 会把该线程放入锁池中。</li>
<li>其它阻塞（<code>sleep/join</code>）：运行(running)的线程执行 <code>Thread.sleep(long ms)</code>或<code>t.join()</code>方法，或者发出了 I/O 请求时，<code>JVM</code> 会把该线程置为阻塞状态。当 <code>sleep()</code>状态超时、<code>join()</code>等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ul>
</li>
<li><strong>死亡状态</strong>：线程对象编程垃圾，等待被回收。线程会以下面三种方式结束，结束后就是死亡状态<ul>
<li>正常结束：<code>run()</code>/ <code>call()</code>执行完成</li>
<li>异常结束：线程抛出一个未捕获的 <code>Exception</code> 或 <code>Error</code>。</li>
<li>调用<code>stop</code>：直接调用该线程的 <code>stop()</code>方法来结束该线程——<strong>该方法通常容易导致死锁，不推荐使用</strong>。至于为什么不推荐使用 <code>stop</code>方法，后面有进行说明</li>
</ul>
</li>
</ul>
<h3 id="3-创建线程方式与注意地方"><a href="#3-创建线程方式与注意地方" class="headerlink" title="3.创建线程方式与注意地方"></a>3.创建线程方式与注意地方</h3><ul>
<li><strong>通过继承 <em>Thread</em>类本身</strong></li>
<li><strong>通过实现 <em>Runable</em> 接口</strong></li>
<li><strong>通过 <em>ExecutorService</em> 与<em>Callable</em> 创建线程</strong></li>
<li><strong>通过 <em>FutureTask</em></strong></li>
</ul>
<p>具体的各个实现方式就不写了，说一下需要注意的地方：</p>
<ul>
<li>当通过实现 <code>Runnable</code> 接口生成一个任务类时候，必须具有 <code>run()</code> 方法，但是这个方法不会产生任何 <strong>内在</strong> 的线程能力，要实现线程能力，必须显示地将这个任务类附着到线程上。</li>
</ul>
<h4 id="3-1-为什么要重写-run-方法呢？"><a href="#3-1-为什么要重写-run-方法呢？" class="headerlink" title="3.1 为什么要重写 run() 方法呢？"></a>3.1 为什么要重写 <code>run()</code> 方法呢？</h4><p>不是类中的所有的代码都需要被多线程执行的。而这个时候，为了区分哪些代码需要被多线程执行的，<code>java</code> 提供了 Thread 中的 <code>run()</code> 用来包含那些需要被多线程执行的代码。</p>
<h4 id="3-2-run-与-start-区别"><a href="#3-2-run-与-start-区别" class="headerlink" title="3.2 run() 与 start() 区别"></a>3.2 <code>run()</code> 与 <code>start()</code> 区别</h4><ul>
<li><code>run()</code>仅仅是封装被线程执行的代码，直接调用则算是普通方法</li>
<li><code>start()</code>首先启动了线程，然后再由 <code>JVM</code> 去调用该线程的 <code>run()</code> 方法</li>
</ul>
<h4 id="3-3-Thread-和-Runnable-区别"><a href="#3-3-Thread-和-Runnable-区别" class="headerlink" title="3.3 Thread 和 Runnable 区别"></a>3.3 Thread 和 Runnable 区别</h4><ul>
<li>Thread 类本质上是实现了 Runnable 接口的一个实例，代表着一个线程实例</li>
<li>启动线程的唯一方法就是 Thread 类的 <code>start()</code>实例方法</li>
</ul>
<h4 id="3-4-Callable-和-Runable-区别"><a href="#3-4-Callable-和-Runable-区别" class="headerlink" title="3.4 Callable 和 Runable 区别"></a>3.4 <code>Callable</code> 和 <code>Runable</code> 区别</h4><ul>
<li><p>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的</p>
</li>
<li><p>Callable规定的方法是call()，Runnable规定的方法是run()</p>
</li>
<li><p>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)</p>
</li>
<li><p>call方法可以抛出异常，run方法不可以</p>
</li>
<li><p>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>
</li>
<li><p>加入线程池运行，Runnable使用<code>ExecutorService</code>的execute方法，Callable使用submit方法。</p>
</li>
</ul>
<h4 id="3-5-Callable-接口"><a href="#3-5-Callable-接口" class="headerlink" title="3.5 Callable 接口"></a>3.5 Callable 接口</h4><p>Callable接口和 Runnable 接口都是位于<code>java.util.concurrent</code>包中。Callable接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;     </span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这是泛型接口，而返回的值类型，就是泛型中指定的类型。</p>
<p>看了定义，那Callable是怎么使用的呢？</p>
<p>一般情况下都是配合 <code>ExecutorService</code>来使用的，在 <code>ExecutorService</code>接口中声明了若干个 <code>submit</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
<h4 id="3-6-Future"><a href="#3-6-Future" class="headerlink" title="3.6 Future"></a>3.6 Future</h4><p>Future 就是对 <code>Runable</code> 或者 <code>Callable</code> 任务的执行结果进行取消、查询是否完成、获取结果。必要的时候可以通过 <code>get</code> 方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>Future接口有以下的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cancel</code> 方法用来取消任务，如果取消任务成功则返回 true，如果失败则返回 false。参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务，如果是true，则表示可以取消，如果是false表示不可以取消此状态的任务。<ul>
<li>如果任务已经执行完成，无论 <code>mayInterruptIfRunning</code> 是什么值，都只返回 false，即取消已经完成的任务，只会返回 false。</li>
<li>如果任务在执行中，若<code>mayInterruptIfRunning</code>为true，则方法返回结果为 true；若<code>mayInterruptIfRunning</code>为false，方法返回结果为false。</li>
<li>如果任务还没有执行，无论 <code>mayInterruptIfRunning</code> 是什么值，方法都返回 true。</li>
</ul>
</li>
<li><code>isCancelled</code> 方法判断任务是否已经被取消。</li>
<li><code>isDone</code> 判断任务是否已经完成</li>
<li><code>get</code>方法用来获取执行结果，<strong>这个方法会产生阻塞，会一直等任务执行完毕才返回。</strong></li>
<li><code>get(long timeout, TimeUnit unit)</code> 用来获取执行结果，在指定时间内没能获取到结果，就直接返回 null。</li>
</ul>
<p>总结 Future 的功能就是：</p>
<ul>
<li>判断任务是否完成</li>
<li>能够中断任务</li>
<li>能够获取执行结果</li>
</ul>
<h4 id="3-7-FutureTask"><a href="#3-7-FutureTask" class="headerlink" title="3.7 FutureTask"></a>3.7 FutureTask</h4><p>先看一下 <code>FutureTask</code> 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实现了 <code>RunnableFuture</code>接口，再看一下这个接口定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>RunnableFuture</code> 继承了 <code>Runnable</code> 和 <code>Future</code> 接口，而 <code>FutureTask</code> 实现了 <code>RunnableFuture</code> 接口。所以 <code>FutureTask</code>既可以作为 <code>Runnable</code>被线程执行，又可以作为 <code>Future</code> 得到 <code>Callable</code> 的返回值。</p>
<p><code>FutureTask</code>提供了两个构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span></span>;</span><br></pre></td></tr></table></figure>
<p>事实上，在 <code>jdk</code> 中 <code>FutureTask</code> 是 <code>Future</code> 接口的唯一实现类。</p>
<h3 id="4-手动结束（终止）线程"><a href="#4-手动结束（终止）线程" class="headerlink" title="4.手动结束（终止）线程"></a>4.手动结束（终止）线程</h3><p><code>stop</code>方法的不安全性在于<strong>该方法会释放线程所持有的锁</strong>，导致被污染的数据暴露给其他线程。简单来说，就是<code>stop</code>方法会“突然”停止线程并释放锁而来不及做“善后”工作（如回滚操作），从而使结果变得不可预期。</p>
<p>此外，<strong>当线程持有本身的锁时</strong>，<code>stop</code>方法是无法起效的，需等到线程释放自身的锁才能终止该线程。这是由于<code>Thread</code>的<code>stop()</code>会调用<code>stop(Throwable obj)</code>方法，而该方法是一个同步方法。</p>
<p>如下例中，<code>thread</code>线程首先锁住了自己，因此可以完整打印出0~499而不被<code>stop</code>，只有当<code>thread</code>线程释放了自身的锁，<code>stop</code>方法才能获得锁而运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//锁住线程本身</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">                        System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.sleep(<span class="number">1</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于stop的不安全性，接口文档中也给出了推荐的做法：</p>
<ol>
<li>给定一个终止线程的标记位，当需要终止线程的时候设置这个标记位，而线程本身应当定期检查这个标记位，当检测到终止标记时，“优雅”地结束自己。</li>
<li>对于阻塞的线程，应当使用<code>interrupt</code>方法来终止等待。</li>
</ol>
<h4 id="4-1-用标记位手动善后"><a href="#4-1-用标记位手动善后" class="headerlink" title="4.1 用标记位手动善后"></a>4.1 用标记位手动善后</h4><p>下例给出了推荐做法1的简单实现，我们给定了<code>terminateFlag</code>来作为终止线程的标记位，当外部调用线程的<code>terminate</code>方法时会将该标记位设为 true。而在每次打印数字前会判断该标记位是否置 true，即是否需要终止线程。<strong>当需要终止线程时，先做一些善后工作</strong>，如打印出剩余的数字个数等，再break跳出循环结束自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> terminateFlag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!terminateFlag) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                System.out.println(<span class="string">"thread stop, count of remaining numbers: "</span> + (<span class="number">500</span> - i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        terminateFlag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-用interrupt方法终止阻塞的线程"><a href="#4-2-用interrupt方法终止阻塞的线程" class="headerlink" title="4.2 用interrupt方法终止阻塞的线程"></a>4.2 用interrupt方法终止阻塞的线程</h4><p>先看一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        thread.start();</span><br><span class="line">        thread.sleep(<span class="number">10</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>interrupt</code>方法并不能终止线程，0~499的数字可以完整地打印出来。</p>
<p>那么<code>interrupt</code>方法究竟做了什么？</p>
<p>实际上该方法仅仅会将<code>interruptflag</code>置为true，这个标记位可以通过<code>isInterrupted()</code>方法来获取，我们将这个标记位打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    System.out.println(<span class="string">"interrupt flag: "</span> + <span class="keyword">this</span>.isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.sleep(<span class="number">10</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现当打印251时，interrupt flag已经被置为true，但并没有影响线程的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">249</span></span><br><span class="line">interrupt flag: <span class="keyword">false</span></span><br><span class="line"><span class="number">250</span></span><br><span class="line">interrupt flag: <span class="keyword">false</span></span><br><span class="line"><span class="number">251</span></span><br><span class="line">interrupt flag: <span class="keyword">true</span></span><br><span class="line"><span class="number">252</span></span><br><span class="line">interrupt flag: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>那<code>interrupt</code>方法究竟是用来做什么的？为什么说该方法可以用来终止阻塞中的线程呢？实际上，在Thread的<code>sleep</code>和Object的<code>wait</code>方法的底层实现中，都会检测<code>interrupt</code>标记位，当发现该标记位为true时会抛出<code>InterruptException</code>，因此当调用sleep和wait方法时都需要捕获并处理<code>InterruptException</code>，且可以在catch到该异常后停止自己，从而达到终止阻塞中线程的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        thread.start();</span><br><span class="line">        thread.sleep(<span class="number">50</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-线程的调度"><a href="#5-线程的调度" class="headerlink" title="5. 线程的调度"></a>5. 线程的调度</h3><h4 id="5-1线程调度"><a href="#5-1线程调度" class="headerlink" title="5.1线程调度"></a>5.1线程调度</h4><p>计算机CPU在某一时刻，只能执行一条指令，线程只有得到CPU的权限，才可以执行指令。线程如何得到CPU的权限，可以算是线程的调度。  </p>
<p>多线程的程序一次运行的结果可能和另一次运行的结果不同，因为线程的调度机制是非确定性的。</p>
<h4 id="5-2线程调度的两种模型"><a href="#5-2线程调度的两种模型" class="headerlink" title="5.2线程调度的两种模型"></a>5.2线程调度的两种模型</h4><ul>
<li><strong>分时调度模型</strong>：平均分配给每一个线程，使用时间相同</li>
<li><strong>抢占式调度模型</strong>：通过优先级，分配 CPU 权限，java 就是这种模型</li>
</ul>
<h4 id="5-3如何设置优先级"><a href="#5-3如何设置优先级" class="headerlink" title="5.3如何设置优先级"></a>5.3如何设置优先级</h4><p><strong>默认优先级</strong>：5<br><strong>优先级范围</strong>：1-10<br><strong>用到的方法</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> 	返回线程优先级  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> 更改线程的优先级。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-线程控制"><a href="#6-线程控制" class="headerlink" title="6.线程控制"></a>6.线程控制</h3><ul>
<li>线程休眠：public static void sleep(long millis)<blockquote>
<p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。  </p>
</blockquote>
</li>
<li><p>等待线程：public final void join()</p>
<blockquote>
<p>等待该线程终止。</p>
</blockquote>
</li>
<li><p>线程礼让：public static void yield()</p>
<blockquote>
<p>暂停当前正在执行的线程对象，并执行其他线程。  </p>
</blockquote>
</li>
<li><p>后台线程：public final void setDaemon(boolean on)</p>
<blockquote>
<p>将该线程标记为守护线程或用户线程。</p>
<blockquote>
<p>所谓<strong>守护线程</strong>，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。<strong>因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程</strong>。</p>
</blockquote>
</blockquote>
</li>
<li><p>中断线程：public final void stop() 与 public void interrupt()</p>
<blockquote>
<p>其中 stop() 这个方法已经过时了，具有安全隐患</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>interrupt()  <strong>中断线程</strong>， 如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。 </p>
</blockquote>
<p>举个例子说明吧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> run()&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始执行："</span>+<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"抛出异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"结束执行："</span>+<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)&#123;</span><br><span class="line"></span><br><span class="line">        MyThread myThread1=<span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread1.setName(<span class="string">"靓仔"</span>);</span><br><span class="line">        myThread1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            myThread1.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始执行：Sun Feb 19 23:07:15 CST 2017</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>明显我们可以看到后面还有程序需要运行的，它也没有运行，也没有运行 catch 块部分的内容，我们将 stop() 换成 interrupt() 方法之后看下输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始执行：Sun Feb 19 23:09:51 CST 2017</span><br><span class="line">抛出异常</span><br><span class="line">结束执行：Sun Feb 19 23:09:54 CST 2017</span><br></pre></td></tr></table></figure></p>
<p>换成 interrupt() 之后，能执行后面需要的程序。</p>
<h3 id="7-线程池"><a href="#7-线程池" class="headerlink" title="7.线程池"></a>7.线程池</h3><p>参考资料：<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">线程池</a></p>
<h4 id="7-1-使用场景"><a href="#7-1-使用场景" class="headerlink" title="7.1 使用场景"></a>7.1 使用场景</h4><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<ul>
<li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>第三：提高线程的可管理性。</li>
</ul>
<blockquote>
<p>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
</blockquote>
<h4 id="7-2-如何实现线程池代码"><a href="#7-2-如何实现线程池代码" class="headerlink" title="7.2 如何实现线程池代码"></a>7.2 如何实现线程池代码</h4><ul>
<li>创建一个线程池对象，控制要创建几个线程对象<br><code>public static ExecutorService newFixedThreadPool(int nThread)</code></li>
<li>这种线程池的线程可以执行：<br><code>1. 可以执行Runnable对象或者Callable对象代表的线程</code><br><code>2.做一个类实现Runnable接口</code></li>
<li>调用如下方法即可<br><code>Future&lt;?&gt; submit(Runnable task)</code><br><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>  </li>
<li>可以结束<br><code>调用shutdown()</code></li>
</ul>
<h4 id="7-3-执行线程"><a href="#7-3-执行线程" class="headerlink" title="7.3 执行线程"></a>7.3 执行线程</h4><p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>submit()方法是在 ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果</p>
<h4 id="7-4线程池的关闭"><a href="#7-4线程池的关闭" class="headerlink" title="7.4线程池的关闭"></a>7.4线程池的关闭</h4><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<ul>
<li><strong>shutdown()</strong>：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li><strong>shutdownNow()</strong>：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">for</span> (int x=<span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"-----"</span>+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService pool= Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        </span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-5-线程池类型"><a href="#7-5-线程池类型" class="headerlink" title="7.5 线程池类型"></a>7.5 线程池类型</h4><p>Java 中的线程池顶级接口是 <code>Executor</code>，但是严格意义上讲 <code>Executor</code> 并不是一个线程池，而是一个执行线程的工具。真正的线程池接口是 <code>ExecutorService</code>.</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553748353726&amp;di=4834648bf389a42e083e2edab40fba45&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D947447203%2C3545120712%26fm%3D214%26gp%3D0.jpg" alt=""></p>
<h5 id="7-5-1-newCachedThreadPool"><a href="#7-5-1-newCachedThreadPool" class="headerlink" title="7.5.1 newCachedThreadPool"></a>7.5.1 <em>newCachedThreadPool</em></h5><p>创建一个可根据需要而<strong>自动创建新线程</strong>的线程池，但在之前创建好的线程可用时，会优先重用已经创建好的。</p>
<p>对于执行一些短期异步任务而言，重用已经创建好的线程资源，可以提高程序的性能。</p>
<p>调用 <code>execute</code>方法将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则会创建一个新的线程加入线程池中。</p>
<p>终止从缓存中移除那些已有 60 秒未被使用的线程。所以长时间保持空闲的线程不会使用任何资源。</p>
<h5 id="7-5-2-newFixedThreadPool"><a href="#7-5-2-newFixedThreadPool" class="headerlink" title="7.5.2 newFixedThreadPool"></a>7.5.2 <em>newFixedThreadPool</em></h5><p>创建一个可从重用<strong>固定线程数</strong>的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。<strong>在某个线程被显式地关闭之前，池中的线程将一直存在。</strong></p>
<h5 id="7-5-3-newScheduledThreadPool"><a href="#7-5-3-newScheduledThreadPool" class="headerlink" title="7.5.3 newScheduledThreadPool"></a>7.5.3 <em>newScheduledThreadPool</em></h5><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>延时执行：下面程序表示延迟3秒执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    executorService.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"delay 3 second ~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; , <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定期执行：表示延迟1秒后每3秒执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"delay 3 second ~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; , <span class="number">1</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-5-4-newSingleThreadExecutor"><a href="#7-5-4-newSingleThreadExecutor" class="headerlink" title="7.5.4 newSingleThreadExecutor"></a>7.5.4 <em>newSingleThreadExecutor</em></h5><p><code>Executors.newSingleThreadExecutor()</code>返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p>
<h3 id="8-线程的基本方法（updating"><a href="#8-线程的基本方法（updating" class="headerlink" title="8. 线程的基本方法（updating~)"></a>8. 线程的基本方法（updating~)</h3><p>sleep 与 wait 区别</p>
<ul>
<li>sleep 方法属于 Thread 类。而 wait 方法属于 Object 类。</li>
<li>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是<strong>他的监控状态依然</strong><br><strong>保持着</strong>，当指定的时间到了又会自动恢复运行状态。</li>
<li>在调用 sleep()方法的过程中，线程不会释放对象锁</li>
<li>而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此<br>对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
</ul>
<hr>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.limisky.com/122.html" target="_blank" rel="noopener">Java Thread的stop和interrupt方法</a></p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://yoursite.com">ALemon</a>
            </p><p>原文链接：<a href="http://yoursite.com/2019/03/20/Java 多线程（并发）/">http://yoursite.com/2019/03/20/Java 多线程（并发）/</a>
            </p><p>发表日期：<a href="http://yoursite.com/2019/03/20/Java 多线程（并发）/">March 20th 2019, 10:08:45 am</a>
            </p><p>更新日期：<a href="http://yoursite.com/2019/03/20/Java 多线程（并发）/">March 31st 2019, 11:43:44 am</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2019/03/30/Java中的锁/" title="Java 锁（updating）">
                    <div class="nextTitle">Java 锁（updating）</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2019/03/05/volatile是什么/" title="volatitle 是什么？">
                    <div class="prevTitle">volatitle 是什么？</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:756775896@qq.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="https://github.com/a998151" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-进程与线程"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-并发的目的"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 并发的目的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-线程的生命周期"><span class="toc-number">2.</span> <span class="toc-text">2.线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-创建线程方式与注意地方"><span class="toc-number">3.</span> <span class="toc-text">3.创建线程方式与注意地方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-为什么要重写-run-方法呢？"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 为什么要重写 run() 方法呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-run-与-start-区别"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 run() 与 start() 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Thread-和-Runnable-区别"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Thread 和 Runnable 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Callable-和-Runable-区别"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 Callable 和 Runable 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-Callable-接口"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 Callable 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-Future"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-FutureTask"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 FutureTask</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-手动结束（终止）线程"><span class="toc-number">4.</span> <span class="toc-text">4.手动结束（终止）线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-用标记位手动善后"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 用标记位手动善后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-用interrupt方法终止阻塞的线程"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 用interrupt方法终止阻塞的线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-线程的调度"><span class="toc-number">5.</span> <span class="toc-text">5. 线程的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1线程调度"><span class="toc-number">5.1.</span> <span class="toc-text">5.1线程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2线程调度的两种模型"><span class="toc-number">5.2.</span> <span class="toc-text">5.2线程调度的两种模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3如何设置优先级"><span class="toc-number">5.3.</span> <span class="toc-text">5.3如何设置优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-线程控制"><span class="toc-number">6.</span> <span class="toc-text">6.线程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-线程池"><span class="toc-number">7.</span> <span class="toc-text">7.线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-使用场景"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-如何实现线程池代码"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 如何实现线程池代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-执行线程"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 执行线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4线程池的关闭"><span class="toc-number">7.4.</span> <span class="toc-text">7.4线程池的关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-线程池类型"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 线程池类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-1-newCachedThreadPool"><span class="toc-number">7.5.1.</span> <span class="toc-text">7.5.1 newCachedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-2-newFixedThreadPool"><span class="toc-number">7.5.2.</span> <span class="toc-text">7.5.2 newFixedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-3-newScheduledThreadPool"><span class="toc-number">7.5.3.</span> <span class="toc-text">7.5.3 newScheduledThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-4-newSingleThreadExecutor"><span class="toc-number">7.5.4.</span> <span class="toc-text">7.5.4 newSingleThreadExecutor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-线程的基本方法（updating"><span class="toc-number">8.</span> <span class="toc-text">8. 线程的基本方法（updating~)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文章"><span class="toc-number">9.</span> <span class="toc-text">参考文章</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 18
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span><a class="archive-post-title" href="/2019/05/09/单点登陆/">单点登陆</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href="/2019/05/03/Java集合——Set/">Java集合——Set</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/02</span><a class="archive-post-title" href="/2019/05/02/Java集合——List/">Java集合——List</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span><a class="archive-post-title" href="/2019/05/01/数据库管理系统（DBMS）——事务隔离级别/">数据库管理系统（DBMS）——事务与隔离级别</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href="/2019/04/13/数据库管理系统（DBMS）——读现象/">数据库管理系统（DBMS）——读现象</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span><a class="archive-post-title" href="/2019/04/11/数据库管理系统（DBMS）——共享锁与排他锁/">数据库管理系统（DBMS）——共享锁与排他锁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href="/2019/04/10/数据库管理系统（DBMS）——死锁/">数据库管理系统（DBMS）——死锁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href="/2019/04/10/数据库管理系统（DBMS）——行锁、表锁、页锁/">数据库管理系统（DBMS）中的锁——行锁、表锁、页锁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/30</span><a class="archive-post-title" href="/2019/03/30/Java中的锁/">Java 锁（updating）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/20</span><a class="archive-post-title" href="/2019/03/20/Java 多线程（并发）/">Java 多线程（并发）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/05</span><a class="archive-post-title" href="/2019/03/05/volatile是什么/">volatitle 是什么？</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span><a class="archive-post-title" href="/2019/03/01/static 多线程/">Java中多线程的static</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/28</span><a class="archive-post-title" href="/2019/02/28/原子性、可见性、有序性/">原子性、可见性、有序性</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span><a class="archive-post-title" href="/2019/02/04/final 关键字深入理解/">final 关键字的理解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href="/2019/01/04/类型信息/">Java——Class</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href="/2018/12/21/泛型/">泛型使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href="/2018/10/24/Java初认识锁机制/">Java初认识锁机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span><a class="archive-post-title" href="/2018/10/04/Java 中的 ==, equals 与 hashCode 的区别与联系/">Java 中的 ==、equals 与 hashCode</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="锁机制"><span class="iconfont-archer">&#xe606;</span>锁机制</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="TCP"><span class="iconfont-archer">&#xe606;</span>TCP</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="锁"><span class="iconfont-archer">&#xe606;</span>锁</span>
    
        <span class="sidebar-tag-name" data-tags="单点登陆"><span class="iconfont-archer">&#xe606;</span>单点登陆</span>
    
        <span class="sidebar-tag-name" data-tags="SSO"><span class="iconfont-archer">&#xe606;</span>SSO</span>
    
        <span class="sidebar-tag-name" data-tags="OAuth2.0"><span class="iconfont-archer">&#xe606;</span>OAuth2.0</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="java-锁"><span class="iconfont-archer">&#xe60a;</span>java-锁</span>
    
        <span class="sidebar-category-name" data-categories="java"><span class="iconfont-archer">&#xe60a;</span>java</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "ALemon"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


